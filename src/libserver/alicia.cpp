#include <bit>

#include "libserver/alicia.hpp"
#include "libserver/mapping.hpp"

namespace
{

} // namespace anon

alicia::MessageMagic alicia::decode_message_magic(
  uint32_t value)
{
  MessageMagic magic;
  if (value & 1 << 15) {
    const uint16_t section = value & 0x3FFF;
    magic.length = (value & 0xFF) << 4 | section >> 8 & 0xF | section & 0xF000;
  }

  const uint16_t firstTwoBytes = value & 0xFFFF;
  const uint16_t secondTwoBytes = value >> 16 & 0xFFFF;
  const uint16_t xorResult = firstTwoBytes ^ secondTwoBytes;
  magic.id = ~(xorResult & 0xC000) & xorResult;

  return magic;
}

uint32_t alicia::encode_message_magic(
  MessageMagic magic)
{
  const uint16_t id = BufferJumbo & 0xFFFF | magic.id & 0xFFFF;
  const uint32_t length = BufferSize << 16 | magic.length;

  uint32_t encoded = length;
  encoded = (encoded & 0x3FFF | encoded << 14) & 0xFFFF;
  encoded = ((encoded & 0xF | 0xFF80) << 8 | length >> 4 & 0xFF | encoded & 0xF000) & 0xFFFF;
  encoded |= (encoded ^ id) << 16;
  return encoded;
}

void alicia::read(std::istream& stream, std::string& val)
{
  while(true) {
    char v{0};
    stream.read(&v, sizeof(v));
    if(v == 0)
      break;
    val += v;
  }
}

void alicia::AcCmdCLLogin::Deserialize(std::istream& buffer)
{
  read(buffer, constant0);
  read(buffer, constant1);
  read(buffer, login_id);
  read(buffer, member_no);
  read(buffer, auth_key);
}

void alicia::Client::read_loop()
{
  _socket.async_read_some(_buffer.prepare(4096), [&](boost::system::error_code error, std::size_t size) {
    if(error) {
      printf(
          "Error occurred on read loop with client on port %d. What: %s\n",
          _socket.remote_endpoint().port(),
          error.message().c_str());
      return;
    }

    // Commit the recieved buffer.
    _buffer.commit(size);

    std::istream stream(&_buffer);

    // Read the message magic.
    uint32_t magic = 0;
    read(stream, magic);
    if(magic == 0x0) {
      throw std::runtime_error("invalid message magic");
    }

    const auto message_magic = decode_message_magic(magic);

    // Read the message data.
    std::vector<uint8_t> data;
    data.resize(message_magic.length - 4);
    read(stream, data);

    // XOR decode
    xor_codec_cpp(data);

    printf("Received message ID: 0x%X (%s), length: %d (-4)\n",
           message_magic.id, alicia::GetMessageName(message_magic.id).data(),message_magic.length);

    uint16_t responseId = 0x0;
    std::vector<uint8_t> message;

    if (message_magic.id == 0x7)
    {
      responseId = 0x8;
      message = {
          0xC2, 0x8,  0x40, 0xA7, 0xF2, 0xB7, 0xDA, 0x1,  0x94, 0xA7, 0xC,  0x0,  0xE8, 0xE2, 0x6,  0x0,  0x72, 0x67,
          0x6E, 0x74, 0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0xA,  0x0,  0xB1, 0x8D, 0x0,  0x0,  0x30, 0x61, 0x0,  0x0,
          0x0,  0x0,  0x0,  0x0,  0x0,  0x19, 0x0,  0x0,  0x0,  0xC,  0x1,  0x0,  0x16, 0x57, 0x2,  0x0,  0x15, 0x41,
          0x3,  0x0,  0x17, 0x44, 0x4,  0x0,  0x18, 0x53, 0x5,  0x0,  0x12, 0x13, 0x6,  0x0,  0x82, 0x83, 0x7,  0x0,
          0x20, 0x2F, 0x8,  0x0,  0x46, 0x0,  0x9,  0x0,  0x52, 0x0,  0xA,  0x0,  0x19, 0x0,  0xB,  0x0,  0xF,  0x0,
          0xC,  0x0,  0x43, 0x0,  0x2F, 0x77, 0x69, 0x6E, 0x6B, 0x2F, 0x77, 0x61, 0x76, 0x65, 0x0,  0x54, 0x68, 0x61,
          0x6E, 0x6B, 0x20, 0x79, 0x6F, 0x75, 0x21, 0x20, 0x2F, 0x68, 0x65, 0x61, 0x72, 0x74, 0x0,  0x2F, 0x66, 0x69,
          0x72, 0x65, 0x2F, 0x66, 0x69, 0x72, 0x65, 0x2F, 0x66, 0x69, 0x72, 0x65, 0x20, 0x46, 0x69, 0x72, 0x65, 0x21,
          0x20, 0x2F, 0x66, 0x69, 0x72, 0x65, 0x2F, 0x66, 0x69, 0x72, 0x65, 0x2F, 0x66, 0x69, 0x72, 0x65, 0x0,  0x2F,
          0x73, 0x61, 0x64, 0x2F, 0x63, 0x72, 0x79, 0x20, 0x53, 0x6F, 0x72, 0x72, 0x79, 0x21, 0x20, 0x2F, 0x63, 0x72,
          0x79, 0x2F, 0x73, 0x61, 0x64, 0x0,  0x2F, 0x2D, 0x74, 0x61, 0x64, 0x61, 0x20, 0x43, 0x6F, 0x6E, 0x67, 0x72,
          0x61, 0x74, 0x75, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x21, 0x21, 0x21, 0x20, 0x2F, 0x74, 0x61, 0x64,
          0x61, 0x0,  0x2F, 0x63, 0x6C, 0x61, 0x70, 0x20, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x47, 0x61, 0x6D, 0x65, 0x21,
          0x20, 0x2F, 0x2D, 0x63, 0x6C, 0x61, 0x70, 0x0,  0x42, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x62,
          0x61, 0x63, 0x6B, 0x21, 0x20, 0x50, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x20, 0x77, 0x61, 0x69, 0x74, 0x20, 0x66,
          0x6F, 0x72, 0x20, 0x6D, 0x65, 0x21, 0x20, 0x2F, 0x77, 0x69, 0x6E, 0x6B, 0x0,  0x53, 0x65, 0x65, 0x20, 0x79,
          0x6F, 0x75, 0x21, 0x20, 0x2F, 0x73, 0x6D, 0x69, 0x6C, 0x65, 0x2F, 0x77, 0x61, 0x76, 0x65, 0x0,  0x64, 0x0,
          0x0,  0x0,  0x10, 0x0,  0x7,  0x18, 0x0,  0x1,  0x2,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x1F, 0x0,
          0x1,  0x2,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x23, 0x0,  0x1,  0x2,  0x0,  0x0,  0x0,  0x1,  0x0,
          0x0,  0x0,  0x29, 0x0,  0x1,  0x2,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x2A, 0x0,  0x1,  0x2,  0x0,
          0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x2B, 0x0,  0x1,  0x2,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x2E,
          0x0,  0x1,  0x2,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x0,  0x6D, 0xC9, 0xD7, 0x15, 0x39, 0x89, 0x90,
          0x85, 0xC,  0x11, 0xA,  0x0,  0x0,  0x1,  0x1,  0x0,  0x4,  0x0,  0x8,  0x0,  0x8,  0x0,  0x8,  0x0,  0x0,
          0x0,  0x96, 0xA3, 0x79, 0x5,  0x21, 0x4E, 0x0,  0x0,  0x69, 0x64, 0x6F, 0x6E, 0x74, 0x75, 0x6E, 0x64, 0x65,
          0x72, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x0,  0x2,  0x3,  0x3,  0x3,  0x4,  0x4,  0x5,  0x3,  0x4,  0x0,  0x0,
          0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x12, 0x0,  0x0,  0x0,
          0x0,  0x0,  0x0,  0x0,  0x15, 0x1,  0x2,  0x2,  0x0,  0xD0, 0x7,  0x3C, 0x0,  0x1C, 0x2,  0x0,  0x0,  0xE8,
          0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xE8, 0x3,  0x1E, 0x0,  0xA,  0x0,  0xA,  0x0,  0xA,  0x0,  0x0,
          0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xE4, 0x67, 0xA1, 0xB8, 0x2,  0x0,  0x7D, 0x2E, 0x3,  0x0,  0x0,  0x0,
          0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0xFE, 0x1,  0x0,
          0x0,  0x21, 0x4,  0x0,  0x0,  0xF8, 0x5,  0x0,  0x0,  0xA4, 0xCF, 0x0,  0x0,  0xE4, 0x67, 0xA1, 0xB8, 0x0,
          0x0,  0x0,  0x0,  0xA,  0x6,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xF,  0x0,  0x0,  0x0,  0x4,  0x0,
          0x0,  0x0,  0x1B, 0x0,  0x0,  0x0,  0x2,  0x0,  0x0,  0x0,  0x1E, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
          0x1F, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x25, 0x0,  0x0,  0x0,  0x30, 0x75, 0x0,  0x0,  0x35, 0x0,
          0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x42, 0x0,  0x0,  0x0,  0x2,  0x0,  0x0,  0x0,  0x43, 0x0,  0x0,  0x0,
          0x4,  0x0,  0x0,  0x0,  0x45, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x6,  0xE,  0x0,  0x0,  0x0,  0x0,
          0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x2B, 0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0xDB,
          0x87, 0x1B, 0xCA, 0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
          0x0,  0x4,  0x96, 0xA3, 0x79, 0x5,  0x12, 0x0,  0x0,  0x0,  0xE4, 0x67, 0x6E, 0x1,  0x3A, 0x0,  0x0,  0x0,
          0x8E, 0x3,  0x0,  0x0,  0xC6, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
          0x0,  0x0,  0x0};
    }
    // AcCmdCLShowInventory
    else if (message_magic.id == 0x7E)
    {
      // AcCmdCLShowInventoryOK
      // verified
      responseId = 0x7F;
      message = {
          0x0};
    }
    // AcCmdCLRequestLicenseInfo
    else if (message_magic.id == 0x52A)
    {
      // AcCmdCLRequestLicenseInfoOK
      responseId = 0x52b;
      message = {
          0x0};
    }
    // AcCmdCLRequestLeagueInfo
    else if (message_magic.id == 0x31F)
    {
      // AcCmdCLRequestLeagueInfoOK
      responseId = 0x320;
      message = {
          0x0};
    }
    // AcCmdCLAchievementCompleteList
    else if (message_magic.id == 0x31F)
    {
      // AcCmdCLAchievementCompleteListOK
      responseId = 0xe7;
//      message = {
//          0x00, 0x00, 0x00, 0x00, // member0
//          0x00, 0x00, 0x00, 0x00, // member1
//          0x00, 0x00, // member2
//          0x00, 0x00,
//          0x00, 0x00,
//          0x0 // member3
//      };
      message = {0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x1, 0x1, 0x1, 0x0, 0x0, 0x34, 0x1, 0x0, };
    }
    // AcCmdCLShowMountList
    else if(message_magic.id == 0x43D)
    {
      // AcCmdCLShowMountListOK
      responseId = 0x43e;
      message = {
          0x0};
    }
    // AcCmdCLShowEggList
    else if(message_magic.id == 0x431)
    {
      // AcCmdCLShowEggListOK
      responseId = 0x432;
      message = {
          0x0};
    }
    // AcCmdCLShowCharList
    else if(message_magic.id == 0x4C8)
    {
      // AcCmdCLShowCharListOK
      responseId = 0x4c9;
      message = {
          0x0};
    }
    // AcCmdCLRequestMountEquipmentList
    else if(message_magic.id == 0x47A)
    {
      // AcCmdCLRequestMountEquipmentListOK
      responseId = 0x47B;
      message = {
          0x00, 0x00, 0x00, 0x00, // member0
          0x00, // length
              };
    }
    // AcCmdCLEnterChannel
    else if(message_magic.id == 0x2B)
    {
      // AcCmdCLEnterChannelOK
      responseId = 0x2c;
      message = {
          0x00, // member0
          0x00, 0x00 // member1
      };
    }
    // AcCmdCLMakeRoom
    else if(message_magic.id == 0x13)
    {
      // AcCmdCLMakeRoomOK
      responseId = 0x14;
      message = {
          0x00, 0x00, 0x00, 0x00,// member0
          0x00, 0x00, 0x00, 0x00,// member1
          0x00, 0x00, // port
          0x00, // member2
      };
    }


    //xor_codec_cpp(message);

    if (responseId != 0x0)
    {
      uint32_t responseMagic = alicia::encode_message_magic({responseId, static_cast<uint16_t>(message.size() + 4)});
      _socket.write_some(asio::const_buffer(reinterpret_cast<const char*>(&responseMagic), sizeof(responseMagic)));
      _socket.write_some(asio::const_buffer(message.data(), message.size()));
    }
    read_loop();
  });
}

void alicia::Server::host()
{
  asio::ip::tcp::endpoint server_endpoint(asio::ip::tcp::v4(), 10030);
  printf("Hosting the server on port 10030\n");
  _acceptor.open(server_endpoint.protocol());
  _acceptor.bind(server_endpoint);
  _acceptor.listen();
  accept_loop();
}

void alicia::Server::accept_loop()
{
  _acceptor.async_accept([&](boost::system::error_code error, asio::ip::tcp::socket client_socket) {
    printf("Accepted new client from port %d\n", client_socket.remote_endpoint().port());
    const auto [itr, _] = _clients.emplace(client_id++, std::move(client_socket));
    itr->second.read_loop();

    accept_loop();
  });
}